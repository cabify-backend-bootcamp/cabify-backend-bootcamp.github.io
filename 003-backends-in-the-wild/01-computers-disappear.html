
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Computers disappear Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    


    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="02-deploying.html" />
    
    
    <link rel="prev" href="./" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../001-programming-a-backend/">
            
                <a href="../001-programming-a-backend/">
            
                    
                    Programming a backend
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../001-programming-a-backend/01-more-than-one-computer.html">
            
                <a href="../001-programming-a-backend/01-more-than-one-computer.html">
            
                    
                    More than one computer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../001-programming-a-backend/02-serving-an-api.html">
            
                <a href="../001-programming-a-backend/02-serving-an-api.html">
            
                    
                    Serving an API
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../001-programming-a-backend/03-the-backends-backends.html">
            
                <a href="../001-programming-a-backend/03-the-backends-backends.html">
            
                    
                    The backend's backends
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../002-distributed-data/">
            
                <a href="../002-distributed-data/">
            
                    
                    Distributed data
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../002-distributed-data/01-contradictions.html">
            
                <a href="../002-distributed-data/01-contradictions.html">
            
                    
                    Contradictions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../002-distributed-data/02-persistent-state.html">
            
                <a href="../002-distributed-data/02-persistent-state.html">
            
                    
                    Persistent state
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../002-distributed-data/03-doing-things-later.html">
            
                <a href="../002-distributed-data/03-doing-things-later.html">
            
                    
                    Doing things later
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../002-distributed-data/04-operation-oriented-databases.html">
            
                <a href="../002-distributed-data/04-operation-oriented-databases.html">
            
                    
                    Operation-oriented databases
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="./">
            
                <a href="./">
            
                    
                    Backends in the wild
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.4.1" data-path="01-computers-disappear.html">
            
                <a href="01-computers-disappear.html">
            
                    
                    Computers disappear
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="02-deploying.html">
            
                <a href="02-deploying.html">
            
                    
                    Deploying
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="03-memory-isnt-infinite.html">
            
                <a href="03-memory-isnt-infinite.html">
            
                    
                    Memory isn't infinite
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="06-observability.html">
            
                <a href="06-observability.html">
            
                    
                    Observability
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../101-appendix-containers/">
            
                <a href="../101-appendix-containers/">
            
                    
                    Containers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../102-appendix-good-practices/">
            
                <a href="../102-appendix-good-practices/">
            
                    
                    Good Practices
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../102-appendix-good-practices/01-general-practices.html">
            
                <a href="../102-appendix-good-practices/01-general-practices.html">
            
                    
                    General Good Practices
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../102-appendix-good-practices/02-design-practices.html">
            
                <a href="../102-appendix-good-practices/02-design-practices.html">
            
                    
                    Design Good Practices
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../102-appendix-good-practices/99-polymorphism-and-abstract-types.html">
            
                <a href="../102-appendix-good-practices/99-polymorphism-and-abstract-types.html">
            
                    
                    Polymorphism and Abstract Types
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Computers disappear</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="computers-disappear">Computers disappear</h1>
<h2 id="disposable-computers-in-robust-systems">Disposable computers in robust systems</h2>
<p>As we&apos;ve seen, there&apos;s no escape to the fact that <strong>computers die</strong> from time to time.</p>
<p>A single computer dying may be a tragedy, especially if you didn&apos;t hit &quot;Save&quot; recently. However, a million interconnected computers dying over time is just distributed systems.</p>
<p>As designers, it&apos;s our job to make our system robust. This requires <strong>planning</strong> in advance that <strong>individual computers</strong> participating on it will die.</p>
<p>A robust system is not one in which its parts are immortal, but <strong>disposable</strong>.</p>
<h2 id="in-a-network-partition-no-one-can-hear-you-scream">In a network partition, no one can hear you scream</h2>
<p>The first step to recover our system from a component&apos;s death is <strong>noticing</strong> that it happened at all.</p>
<p>Obviously, the dead component <strong>won&apos;t tell others that it&apos;s dead</strong>. It may be able to do so in a controlled scenario: a restart, a planned disconnection for maintenance, or something like that. But computers going off can also happen by accident, so we might as well assume that we won&apos;t hear about a computer dying from the computer itself.</p>
<p>This implies that we have to <strong>observe</strong> the death of a computer from the outside, somehow.</p>
<p>We also <strong>don&apos;t have an omniscient monitor</strong> that can observe the system from the outside. As we know, computers in a distributed system communicate through an unreliable network. This network is also the only way we&apos;ve got to observe the health of a computer from the outside.</p>
<p>This implies that <strong>the operation to observe</strong> that a computer has died <strong>is distributed, and, thus, unreliable</strong>.</p>
<h3 id="dead-&#x2248;-not-alive">Dead &#x2248; not alive</h3>
<p>Since a dead computer can&apos;t tell us it&apos;s dead, we need to infer its death from a lack of its opposite: we <strong>try to get proof that it&apos;s alive</strong>. If we fail to do so, then it <strong>looks dead</strong> to us.</p>
<h3 id="death-looks-like-a-network-partition">Death looks like a network partition</h3>
<p>We say it &quot;<em>looks</em> dead&quot;, and not &quot;<em>is</em> dead&quot;, because the computer <strong>may be alive, but we can&apos;t communicate</strong> with it!</p>
<p>When we cannot communicate with a computer that is still alive, we&apos;re under a <em>network partition</em>. In effect, what used to be one network is now two, or more. (Under this definition, a network may just comprise a single computer.)</p>
<p>Both when a computer dies and when it&apos;s on the other side of a partitioned network, to us, it looks like <strong>the computer disappears</strong>.</p>
<p>Network partitions are tricky, because a part of the system <strong>thinking that a computer is dead when it isn&apos;t</strong>, and <strong>other parts</strong> of the system <strong>don&apos;t think the same</strong>, can have bad consequences.</p>
<h2 id="high-availability--no-single-point-of-failure">High availability = no single point of failure</h2>
<p>The buzzword that you want to include in your CV is that you know how to build <em>highly available</em> systems.</p>
<p>A system being <em>available</em> at some given time means that the services it is supposed to be offering can be offered. Availability is <em>higher</em> as more frequent those times are.</p>
<p>A truly <strong>highly available system continues operating correctly under network partitions</strong>. The service it provides may get degraded somehow, but it still serves its purpose.</p>
<p>This is usually a spectrum: we rarely can make systems totally <em>partition-tolerant</em>. Under a total network partition, we give up communication, and some tasks just cannot be performed without communicating with other computers.</p>
<p>At the very least, we can ensure that we have <em>no single point of failure</em>. If any individual component or operation that fails makes your system unavailable, it means that you have a single point of failure.</p>
<h2 id="detecting-failure">Detecting failure</h2>
<p>The mechanisms we use to decide that a computer has disappeared, or, in other words, that it is unavailable, are called <em>failure detectors</em>.</p>
<h3 id="timeouts">Timeouts</h3>
<p>We should be very familiar for now with the most basic of failure detectors: the <em>timeout</em>. If, after enough time has passed, some message you&apos;re expecting from a computer hasn&apos;t arrived, then you decide it is unavailable.</p>
<p>This may be combined with a number of failed retries, to try to account for delayed or lost individual messages.</p>
<h3 id="heartbeats">Heartbeats</h3>
<p>We&apos;ve studied the concept of <strong>connections</strong> on top of unreliable networks. By keeping track of the order of each other&apos;s messages, they can detect out-of-order, duplicate and missing messages and pretend they&apos;re talking over a reliable medium.</p>
<p>But what if one of the computers <strong>loses track</strong> of such order, for example by dying? Then <strong>the connection is</strong> at least partially <strong>broken</strong>.</p>
<p>This will eventually be detected by a timeout when we want to send a new message to it and we don&apos;t get a delivery confirmation in time. Or maybe we get a connection failure response, such as a TCP RST message, instead of a confirmation.</p>
<p>The problem with that approach is that we don&apos;t detect a failure until we actually want to <em>use</em> the connection. If we had detected the failure before, we could have <strong>reacted to it sooner</strong>, when the connection was not in active use, and maybe the service wouldn&apos;t have been as degraded.</p>
<p>Also, in the meantime, maybe the other end has been trying to send us messages too, and, through a similar timeout detector, decided the connection was broken. All that time, the other end and you would be in <strong>disagreement about the health of the connection</strong>, so you wouldn&apos;t try to recover a working connection and you would be missing attempts to communicate with you until then.</p>
<p>Think about a chat application: it would be a terrible experience if it seemed that you were connected and people could talk to you until you decided to talk to someone, only to notice the connection failing at that point. You could spend hours thinking nobody is talking to you, when maybe that&apos;s not the case.</p>
<p>A solution to this is to <strong>periodically confirm with the other end</strong> that the connection is still in place, by sending messages and expecting confirmations with the sole purpose of reaffirming your belief. Those messages are called <em>heartbeats</em>.</p>
<p>If, after a stipulated time, you <strong>haven&apos;t received confirmations</strong> of such messages, or, on the other side, you haven&apos;t received any such messages, you <strong>immediately deem the connection broken</strong>.</p>
<h3 id="health-checks">Health checks</h3>
<p>This is similar to heartbeats. While heartbeats usually are about connections, health checks usually involve a whole machine.</p>
<p>It works like this: a machine <strong>exposes an endpoint</strong> which others can request just for <strong>checking whether the machine is available</strong>, as opposed to actually performing an operation. Some monitor in another machine <strong>periodically calls this endpoint</strong> to get such confirmation. If this fails, then the machine is deemed unavailable.</p>
<p>What should the health check request handler do? It depends. If you do too much, you make the checks more expensive, maybe even affecting your actual service, and less resilient to accidental failures, such as transient networking errors, that don&apos;t really make you unavailable. If you do too little, you may be reporting yourself as available when in reality you can&apos;t do anything useful.</p>
<p>Health checks are often performed by <strong>reverse proxies</strong> to know the available backends they can route requests to, as we&apos;ll see in the next section.</p>
<h2 id="what-then-failover">What then? Failover</h2>
<p>Once we&apos;ve decided a computer is unavailable, what can we do about it?</p>
<p>Since we can&apos;t direct requests to it anymore, what we can do is to send requests to another, similar computer instead. This process is called a <em>failover</em>.</p>
<h3 id="redundancy">Redundancy</h3>
<p>Many processes in our system will be almost <em>stateless</em>. The data they hold is either short-lived, such as open connections, requests in flight, or can be computed or retrieved from some other process, usually a database.</p>
<p>When this is the case, we can just have <strong>several instances of the same program</strong> running, and distribute requests to the service they provide among them. If any of them dies, then we stop directing requests at it, and direct them to any of the other instances instead.</p>
<p>This is usually achieved through a <strong>reverse proxy</strong>, such as HAProxy, Nginx, or <a href="https://www.envoyproxy.io/" target="_blank">Envoy</a>.</p>
<p>It&apos;s a good idea to <strong>keep our programs stateless</strong>, and put data in systems that are designed specifically to store data: databases. Then, any number of stateless programs can connect to a single database.</p>
<h3 id="shadow-followers">Shadow followers</h3>
<p>If we&apos;ve got a good reason to make our program stateful, then we can&apos;t just route any given request to any random backend. Following some sharding criteria, we must direct requests to specific backends. We can <strong>assign a backend to a request</strong> based on session ID, user ID, source IP, or a similar <strong>token</strong> that spans several requests. Then, all the <strong>data associated with that token</strong> will be in its <strong>consistently assigned backend</strong>.</p>
<p>Even for stateless services that randomly assign requests to backends, proxies do this at the connection level: messages inside a TCP connection will be sent to the backend that holds the connection open, In this case, the sharding token is the source and destination port of the connection.</p>
<p>So what happens if the backend assigned to some token disappears? We can&apos;t just randomly reroute its requests to another backend, since the data associated with the token won&apos;t be there.</p>
<p>What we can do is to keep <strong>shadow followers</strong>: instead of a single backend for a token, we assign:</p>
<ul>
<li>A <strong>leader</strong> backend, that processes the requests in full.</li>
<li>Some number of <strong>shadow followers</strong> that are notified somehow of the <strong>state changes</strong> of the leader, so that they can keep the <strong>same data</strong> in them.</li>
</ul>
<p>In the case of failover, one of its shadow replicas are <strong>promoted to leadership</strong>. Since it has the <strong>same state as the previous leader</strong>, it can <strong>take over requests that were directed to it</strong>, almost as if nothing happened.</p>
<p>This is essentially <a href="../002-distributed-data/02-persistent-state.html#backups">what database replicas do</a>, and, as we&apos;ve seen, is pretty hard to do right, so it&apos;s better to leave this work to them if possible.</p>
<h4 id="shadow-followers--stateful-proxies">Shadow followers = stateful proxies</h4>
<p>A problem with this approach is that the proxy needs to keep state: it needs to know which backend, both leader and followers, it has assigned to each token.</p>
<p>So we&apos;ve moved the problem one layer up: <strong>what if the proxy disappears?</strong> We can&apos;t have only a single proxy directing traffic, since that would become a single point of failure.</p>
<p>As you can guess, we need to set up several proxies, and direct traffic from all of those to the right backend, for each request.</p>
<p>But we can&apos;t really follow the leader-followers approach here and assign specific proxies to requests, because <strong>who appoints the leader?</strong> Another proxy? Then it would be proxies all the way down!</p>
<p>This outer-layer distribution of traffic ultimately happens through DNS:</p>
<div class="mermaid">
sequenceDiagram
  participant client1
  participant proxy1
  participant DNS
  participant proxy2
  participant client2
  client1 -&gt;&gt; DNS: get addresses for someservice.com
  DNS -&gt;&gt; client1: 1.2.3.4, 5.6.7.8
  client2 -&gt;&gt; DNS: get addresses for someservice.com
  DNS -&gt;&gt; client2: 1.2.3.4, 5.6.7.8
  Note left of client1: OK, I&apos;ll choose 1.2.3.4 (proxy1)
  Note right of client2: OK, I&apos;ll choose 5.6.7.8 (proxy2)
  client1 -&gt;&gt; proxy1: request
  client2 -&gt;&gt; proxy2: request
</div>

<p>But, in this case, there&apos;s no leader: DNS distributes requests randomly among proxies. If we do nothing else, we end up in a situation in which each proxy assigns requests with the same sharding token to a different backend.</p>
<p>This is a kind of <strong>split-brain scenario</strong>. Keep reading!</p>
<h2 id="split-brain">Split-brain</h2>
<p>Sometimes, there must be one, and only one, computer making decisions about something. Otherwise, they may contradict each other.</p>
<p>This is at odds with high availability: clearly, we cannot have just one computer assigned to some task. What if it disappears? Another computer must take over.</p>
<p>But we must still uphold the guarantee that only one computer at a time is doing the task. Otherwise, we end up in a situation called <em>split-brain</em>: the system has several decision-makers contradicting each other! We must avoid this, but how?</p>
<h3 id="leadership-election">Leadership election</h3>
<p>Appoint a leader through a consensus protocol, usually through something like <a href="https://zookeeper.apache.org/" target="_blank">ZooKeeper</a>, <a href="https://coreos.com/etcd/" target="_blank">etcd</a> or <a href="https://www.consul.io/" target="_blank">Consul</a>.</p>
<p>A database with <a href="../002-distributed-data/01-contradictions.html#transactions">serializable transactions</a> or <a href="../002-distributed-data/01-contradictions.html#compare-and-swap">atomic compare-and-swap support</a>, or a <a href="../002-distributed-data/01-contradictions.html#distributed-locks">distributed lock</a>, or even <a href="../002-distributed-data/02-persistent-state.html#quorum">quorum reads</a> in a leaderless database, might be good enough, though.</p>
<h3 id="dont-outlive-your-leadership">Don&apos;t outlive your leadership</h3>
<p>When you&apos;re a leader, you must <strong>be really sure</strong> that you&apos;re <strong>still the leader</strong> before making sensitive decisions.</p>
<p>Just because you&apos;re alive and you were appointed leader in the past doesn&apos;t mean that you still are.</p>
<p>The sad part is, this is mostly impossible to do. Between the moment we confirm that we&apos;re still leader and we actually do what leaders do, <strong>an indeterminate amount of time may have passed</strong>, even if you do it right after checking, and others may have dismissed you from leadership.</p>
<p>To <em>really</em> avoid split-brain, in the general case, we must let go of high availability: decisions need to go through a single point of failure of some kind. But it&apos;s very rare that we need these extreme amounts of consistency. We probably can live with some level of split-brain risk.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="./" class="navigation navigation-prev " aria-label="Previous page: Backends in the wild">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="02-deploying.html" class="navigation navigation-next " aria-label="Next page: Deploying">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Computers disappear","level":"1.4.1","depth":2,"next":{"title":"Deploying","level":"1.4.2","depth":2,"path":"003-backends-in-the-wild/02-deploying.md","ref":"003-backends-in-the-wild/02-deploying.md","articles":[]},"previous":{"title":"Backends in the wild","level":"1.4","depth":1,"path":"003-backends-in-the-wild/README.md","ref":"003-backends-in-the-wild/README.md","articles":[{"title":"Computers disappear","level":"1.4.1","depth":2,"path":"003-backends-in-the-wild/01-computers-disappear.md","ref":"003-backends-in-the-wild/01-computers-disappear.md","articles":[]},{"title":"Deploying","level":"1.4.2","depth":2,"path":"003-backends-in-the-wild/02-deploying.md","ref":"003-backends-in-the-wild/02-deploying.md","articles":[]},{"title":"Memory isn't infinite","level":"1.4.3","depth":2,"path":"003-backends-in-the-wild/03-memory-isnt-infinite.md","ref":"003-backends-in-the-wild/03-memory-isnt-infinite.md","articles":[]},{"title":"Observability","level":"1.4.4","depth":2,"path":"003-backends-in-the-wild/06-observability.md","ref":"003-backends-in-the-wild/06-observability.md","articles":[]}]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["anchorjs","mermaid-gb3","livereload"],"pluginsConfig":{"livereload":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"mermaid-gb3":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"003-backends-in-the-wild/01-computers-disappear.md","mtime":"2022-04-29T07:27:32.084Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2022-05-25T09:07:35.508Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-mermaid-gb3/book/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    <script src="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.min.js"></script>

    </body>
</html>

