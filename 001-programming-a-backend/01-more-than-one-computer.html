
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>More than one computer Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    


    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="02-serving-an-api.html" />
    
    
    <link rel="prev" href="./" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="./">
            
                <a href="./">
            
                    
                    Programming a backend
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.2.1" data-path="01-more-than-one-computer.html">
            
                <a href="01-more-than-one-computer.html">
            
                    
                    More than one computer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="02-serving-an-api.html">
            
                <a href="02-serving-an-api.html">
            
                    
                    Serving an API
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="03-the-backends-backends.html">
            
                <a href="03-the-backends-backends.html">
            
                    
                    The backend's backends
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../002-distributed-data/">
            
                <a href="../002-distributed-data/">
            
                    
                    Distributed data
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../002-distributed-data/01-contradictions.html">
            
                <a href="../002-distributed-data/01-contradictions.html">
            
                    
                    Contradictions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../002-distributed-data/02-persistent-state.html">
            
                <a href="../002-distributed-data/02-persistent-state.html">
            
                    
                    Persistent state
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../002-distributed-data/03-doing-things-later.html">
            
                <a href="../002-distributed-data/03-doing-things-later.html">
            
                    
                    Doing things later
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../002-distributed-data/04-operation-oriented-databases.html">
            
                <a href="../002-distributed-data/04-operation-oriented-databases.html">
            
                    
                    Operation-oriented databases
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../003-backends-in-the-wild/">
            
                <a href="../003-backends-in-the-wild/">
            
                    
                    Backends in the wild
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../003-backends-in-the-wild/01-computers-disappear.html">
            
                <a href="../003-backends-in-the-wild/01-computers-disappear.html">
            
                    
                    Computers disappear
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../003-backends-in-the-wild/02-deploying.html">
            
                <a href="../003-backends-in-the-wild/02-deploying.html">
            
                    
                    Deploying
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../003-backends-in-the-wild/03-memory-isnt-infinite.html">
            
                <a href="../003-backends-in-the-wild/03-memory-isnt-infinite.html">
            
                    
                    Memory isn't infinite
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../003-backends-in-the-wild/06-observability.html">
            
                <a href="../003-backends-in-the-wild/06-observability.html">
            
                    
                    Observability
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../101-appendix-containers/">
            
                <a href="../101-appendix-containers/">
            
                    
                    Containers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../102-appendix-good-practices/">
            
                <a href="../102-appendix-good-practices/">
            
                    
                    Good Practices
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../102-appendix-good-practices/01-general-practices.html">
            
                <a href="../102-appendix-good-practices/01-general-practices.html">
            
                    
                    General Good Practices
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../102-appendix-good-practices/02-design-practices.html">
            
                <a href="../102-appendix-good-practices/02-design-practices.html">
            
                    
                    Design Good Practices
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../102-appendix-good-practices/99-polymorphism-and-abstract-types.html">
            
                <a href="../102-appendix-good-practices/99-polymorphism-and-abstract-types.html">
            
                    
                    Polymorphism and Abstract Types
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >More than one computer</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="more-than-one-computer">More than one computer</h1>
<h2 id="frontend--backend--distributed-system">Frontend + Backend = Distributed system</h2>
<p>This bootcamp is about backends. The word <em>backend</em> implies being <strong>part of a bigger system</strong> that has, at least, a <em>frontend</em> counterpart of some kind.</p>
<p>Frontends and backends run on <strong>different computers</strong>. Frontends run on user&apos;s devices, such as laptops, mobile phones, or even lightbulbs nowadays.</p>
<p>Frontends and backends need to <strong>talk to each other</strong>. Since they run on different computers, they need to do so <strong>over a network</strong>.</p>
<p>A system comprised of computers that talk to each other over a network is called a <em>distributed system</em>.</p>
<!--
Toni: Let it be clear that distributed systems is not building Google or whatever, it's not necessarily about scale or redundancy, it's about more than one computer collaborating to do something.
-->
<h2 id="computers-send-messages-to-each-other-over-a-medium-that-loses-them">Computers send messages to each other over a medium that loses them</h2>
<p>If you get nothing else from this bootcamp, let it be this:</p>
<blockquote>
<p>Computers send messages to each other over a medium that loses them.</p>
</blockquote>
<p>Everything we&apos;ll learn in this course is just different ways this fact affects building systems that do their job.</p>
<!--
Toni: I think it's better to keep this in mind throughout the course. No "OK, we've built this, now let's see how it can break", but "let's build this, considering where it can break". It's a hard principle to grasp once you're used to single-threaded, single-machine thinking.
-->
<h2 id="the-medium-loses-messages">The medium loses messages</h2>
<p>The physical link between two computers can break. Someone might trip over the wire. If it&apos;s a wireless network, one of them might go into a tunnel. The Internet, composed of millions and millions of links like these, can break in unquantifiable ways.</p>
<p>A consequence of this is that:</p>
<blockquote>
<p>When you send a message, you don&apos;t know whether it will reach its destination.</p>
</blockquote>
<p>But what if it&apos;s important to know that the message reached the other end? After all, you&apos;re trying to get computers to collaborate!</p>
<p>You might suggest: let&apos;s agree with the recipient for them to reply back with another message telling us that they have received the message.</p>
<p>But, in exactly the same fashion, since this message goes through the same unreliable medium, it can be lost too! So we reach another necessary consequence:</p>
<blockquote>
<p>When you don&apos;t get the response you&apos;re expecting, you have no idea if the recipient received your message in the first place.</p>
</blockquote>
<p>A knee-jerk reaction to not getting such a response is to assume that the whole communication failed, that is, that it was <em>your</em> message to the recipient that was lost, not their reply back to you. This assumption doesn&apos;t always work! Think about a monetary transaction: if you tell another computer to move some money, and it doesn&apos;t reply back, you can&apos;t just assume that it didn&apos;t move the money.</p>
<div class="mermaid">
sequenceDiagram
  participant C as Client
  participant S as Server

  C -&gt;&gt;+ S: &quot;Transfer 100$ to Alice&quot;

  note left of S: There&apos;s some delay processing the request.

  C -&gt;&gt; C: &#x1F6A8; Timeout &#x1F6A8;

  note left of S: Retrying...

  C -&gt;&gt;+ S: &quot;Transfer 100$ to Alice&quot;

  S -&gt;&gt;- C: OK
  S -&gt;&gt;- C: OK

  note over C: (Where&apos;s my money?)
</div>

<p>Your solutions <em>must</em> take these two realities into account in order to work robustly. How? Well, keep reading!</p>
<h2 id="you-dont-know-how-long-it-will-take-a-message-to-reach-the-other-side">You don&apos;t know how long it will take a message to reach the other side</h2>
<p>When you are a computer and you&apos;re expecting a message, you have two choices:</p>
<ul>
<li>Wait indefinitely.</li>
<li>Give up after some time.</li>
</ul>
<h3 id="wait-indefinitely">Wait indefinitely</h3>
<p>If you wait indefinitely, the task you&apos;re going to do on receiving the message will be delayed indefinitely. This may mean leaving a user waiting, staring at a spinner, until <em>they</em> give up and close your app, this time <em>really</em> forever. If it&apos;s not a person who&apos;s waiting, but an automatic process of some kind, you might leave that waiting forever.</p>
<p>This is rarely the optimal solution.</p>
<h3 id="give-up-after-some-time">Give up after some time</h3>
<p>This is what we call a <em>timeout</em>.</p>
<p>It works like this: you set a timer alongside an operation that you don&apos;t know how long will take. In our case, waiting for a message from another computer.</p>
<p>If the operation finishes first, then the timer is canceled and everything works. You have successfully coordinated through an ocean of uncertainty, hooray!</p>
<div class="mermaid">
sequenceDiagram
  participant C as Client
  participant S as Server

  C -&gt;&gt; C: Set timer
  C -&gt;&gt;+ S: &quot;Do this&quot;
  S -&gt;&gt;- C: OK
  C -&gt;&gt; C: Cancel timer
</div>

<p>But if the timer finishes first, you <em>cancel</em> the operation (this cancellation might take several forms), acknowledge that the communication failed, and handle the situation as best as you can. We&apos;ll see how.</p>
<div class="mermaid">
sequenceDiagram
  participant C as Client
  participant S as Server

  C -&gt;&gt; C: Set timer
  C -&gt;&gt;+ S: &quot;Do this&quot;

  note left of S: The request has some delay

  C -&gt;&gt; C: &#x1F6A8; Timeout &#x1F6A8;

  C -&gt;&gt; C: Mark operation as failed
</div>


<h4 id="caution-timeouts-tell-you-nothing">Caution: timeouts tell you nothing</h4>
<p>Remember:</p>
<blockquote>
<p>When you don&apos;t get the response you&apos;re expecting, you don&apos;t know if the recipient received your message in the first place.</p>
</blockquote>
<p>To which we may add:</p>
<blockquote>
<p>When you haven&apos;t received the response you&apos;re expecting yet, you don&apos;t know whether you will receive it or not in the future.</p>
</blockquote>
<p>So, on a timeout, there are four possibilities. You haven&apos;t received the response yet because...</p>
<ol>
<li>... your message got lost and never reached nor will it ever reach the recipient, so they can&apos;t reply back.</li>
</ol>
<div class="mermaid">
sequenceDiagram
  participant F as Server A
  participant N as Network (abstract)
  participant B as Server B

  F -&gt;&gt; N: &quot;Do this&quot;

  note right of N: (Some routing failure occurs and message is lost.)

  F -&gt;&gt; F: &#x1F6A8; Timeout &#x1F6A8;
</div>

<ol>
<li>... your message didn&apos;t reach its recipient <em>yet</em>, but it might in the future, so it might reply back eventually.</li>
</ol>
<div class="mermaid">
sequenceDiagram
  participant F as Server A
  participant N as Network (abstract)
  participant B as Server B

  F -&gt;&gt; N: &quot;Do this&quot;

  note right of N: (There&apos;s some delay due to network latency.)

  F -&gt;&gt; F: &#x1F6A8; Timeout &#x1F6A8;

  N -&gt;&gt;+ B: &quot;Do this&quot;
  B -&gt;&gt;- N: OK
  N -&gt;&gt; F: OK

</div>

<ol>
<li>... your message reached the recipient, but the response got lost and you will never receive it.</li>
</ol>
<div class="mermaid">
sequenceDiagram
  participant F as Server A
  participant N as Network (abstract)
  participant B as Server B

  F -&gt;&gt; N: &quot;Do this&quot;
  N -&gt;&gt;+ B: &quot;Do this&quot;

  note left of N: (Some routing failure occurs and message is lost.)

  B -&gt;&gt;- N: OK
  F -&gt;&gt; F: &#x1F6A8; Timeout &#x1F6A8;
</div>

<ol>
<li>... your message reached the recipient; the response hasn&apos;t reached you <em>yet</em>, but it might in the future.</li>
</ol>
<div class="mermaid">
sequenceDiagram
  participant F as Server A
  participant N as Network (abstract)
  participant B as Server B

  F -&gt;&gt; N: &quot;Do this&quot;
  N -&gt;&gt;+ B: &quot;Do this&quot;
  B -&gt;&gt;- N: OK

  note left of N: (There&apos;s some delay due to network latency.)

  F -&gt;&gt; F: &#x1F6A8; Timeout &#x1F6A8;
  N -&gt;&gt; F: OK
</div>

<p>A very <strong>common pitfall</strong> is to assume that, since the communication failed, it never reached and it won&apos;t ever reach the recipient and so it won&apos;t have any effect. This is only true in scenario 1 out of the four.</p>
<p>For example: say your backend calls a database to store something. It expects the database to reply back, either confirming the operation or reporting some kind of error (maybe you didn&apos;t have permissions or something). But the call times out instead. In this case, you can&apos;t tell whether a later read to the database will retrieve the data you intended to store or not.</p>
<p>You should only behave as if you <em>know</em> that the operation has failed (or succeeded) at the other end <strong>if doing so is a reasonable assumption</strong> for your use case. But you have to plan for the consequences. We&apos;ll look more into this.</p>
<p>Another, more subtle, <strong>pitfall</strong> is to assume that, because you have timed out, the message has either reached the recipient (scenarios 3 and 4) or will never reach it (scenario 1). But, in scenario 2, your message could eventually arrive and have an effect at some point in the future! This is especially relevant when retrying the operation; keep reading.</p>
<h2 id="keep-calm-and-embrace-uncertainty">Keep calm and embrace uncertainty</h2>
<p>Let&apos;s start with some good news: <em>most of the time</em>, things just work, especially for simple systems that don&apos;t have a lot of load and don&apos;t depend on a lot of communication; and, <strong><em>most of the time</em>, a simplistic communication failure handling</strong> that just assumes the whole operation failed and aborts gives <strong>good enough</strong> results.</p>
<p>This is because <strong>most operations aren&apos;t critical</strong> and it&apos;s safe if the user just retries them if they want.</p>
<p>For example, when changing the Twitter bio, it&apos;s OK if the user is told &quot;sorry, the operation failed, try again after a while&quot; even if it actually succeeded or will eventually succeed. The user will just click &quot;Save&quot; again and save the same thing, or, if they don&apos;t, maybe they&apos;ll just be surprised later if the aborted bio shows up. No big deal.</p>
<p>But think about monetary transactions and things get ugly fast!</p>
<p>In Cabify, when a journey is finished, the driver sends a &quot;drop-off&quot; message to our backend and our backend charges the rider some amount. What if this message <em>times out</em>?</p>
<p>We can&apos;t just abort the drop-off and leave the journey hanging. Also, we can&apos;t just assume that the drop-off reached the backend and it&apos;s just that its response got lost or delayed. We just don&apos;t know if the operation has succeeded and the rider has been charged or if it has failed and the rider hasn&apos;t been charged. So what can we do?</p>
<p>It&apos;s not enough to just resend the drop-off, like in the simplistic strategy above. If the previous message did get to its recipient, then the rider was charged and when the new drop-off arrives, the rider will be charged again!</p>
<h3 id="continued-retries--idempotency--guaranteed-eventual-success">Continued retries + idempotency = guaranteed eventual success</h3>
<p>What we&apos;re missing is <em>idempotency</em>. Idempotency means that processing the same message any number of times yields the same effects as processing it just once.</p>
<p>Idempotency allows us to retry communicating any number of times without worry. If you don&apos;t get confirmation that a message has succeeded, just retry it! If it didn&apos;t succeed previously, maybe it will now. If it did succeed previously, then the new attempt will just be ignored.</p>
<blockquote>
<p>By retrying an idempotent operation until you see it succeed, you know it will be performed exactly once.</p>
</blockquote>
<p>There are different ways to achieve idempotency. The simplest is to keep track on the backend of which messages you have already processed. When you get a message, you first check if you&apos;ve already processed it. If you have, then you do nothing.</p>
<p>In our example, when our backend processes a drop-off, we internally mark the journey as finished. If we receive the drop-off again, we first check that the journey hasn&apos;t already finished. If it has, then we just do nothing so the rider won&apos;t get charged twice.</p>
<h4 id="caution-communication-success--operation-success">Caution: communication success != operation success</h4>
<p>It&apos;s a <strong>common pitfall</strong> to mix the <em>operation</em> itself with the <em>communication</em> of the operation.</p>
<p>If you ask someone to do something and they respond &quot;no I won&apos;t,&quot; then the <em>operation</em> failed (you didn&apos;t get what you wanted) but the <em>communication</em> succeeded (they heard your request and you heard their response).</p>
<p>If you do the same over the phone and as soon as you have finished asking you enter a tunnel and lose connectivity meaning you never hear the response back, then the <em>communication</em> failed and the operation may or may not have succeeded (they may have said &quot;OK,&quot; hung up and left).</p>
<p>Your natural reaction to this situation would be to call back and ask the same thing:</p>
<ul>
<li><p>If they didn&apos;t hear you before you entered the tunnel, then they&apos;ll either respond &quot;OK&quot; or &quot;no I won&apos;t.&quot; By retrying, you have made sure that the <em>communication</em> has finally succeeded! If you kept accidentally entering tunnels at the worst possible times, then you would just keep calling and eventually you would get the message through, even at the cost of exasperating whoever&apos;s on the other side. (In time, we&apos;ll see how an exasperated <em>server</em> looks like).</p>
</li>
<li><p>If they did hear you before, they&apos;ll typically respond either &quot;again, I won&apos;t&quot; or &quot;I have already performed the operation.&quot; This is idempotency at play! Only very obtuse people would happily do the same thing again. <strong>Idempotency is just common sense to us</strong>; sadly, common sense needs to be taught to the machines. This allows us to repeat communications without fear that we will trigger the consequences too many times.</p>
</li>
</ul>
<p>The point is that <strong>distinguishing communication failure from operation failure</strong> comes naturally to us but not so much to our distributed programs, so we need to be aware of this distinction.</p>
<p>Communication failures are typically called <em>transport layer</em> failures. Operation failures are called <em>application layer</em> failures.</p>
<p>This mix up is <strong>made worse by our programming languages and libraries</strong>, which often report both communication failure and operation failure in a single <code>err</code> variable. Let&#x2019;s look at an example API client request for retrieving an artist from the Spotify API:</p>
<pre><code class="lang-javascript">spotify.getArtist(<span class="hljs-string">&apos;Rosalia&apos;</span>)
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onError</span>(<span class="hljs-params">err</span>) </span>{
    <span class="hljs-built_in">console</span>.log(err);
  });
</code></pre>
<p>In the probable case an error happens, how best to deal with it? One way to deal with these exceptions would be to handle each http status in a different way:</p>
<pre><code class="lang-javascript">spotify.getArtist(<span class="hljs-string">&apos;Rosalia&apos;</span>)
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onError</span>(<span class="hljs-params">err</span>) </span>{
    <span class="hljs-keyword">if</span> (err.status === <span class="hljs-number">400</span>) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;Bad request, Rosalia does not exist.&apos;</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err.status === <span class="hljs-number">401</span>) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;No valid API key provided.&apos;</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err.status === <span class="hljs-number">404</span>) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;The requested resource does not exist.&apos;</span>);
    }
  });
</code></pre>
<p>However, this way of handling the error assumes the error comes from an operational issue when the truth can be much more damning. For example, what happens if the error is in fact due to a timeout in the network request? There&apos;s no status code in there...</p>
<p>This may be the main reason why this is such a common pitfall, combined with the fact that, as we said before in our Twitter bio example, just equating communication failure with operation failure works in many cases.</p>
<h3 id="guaranteed-eventual-success--ordering-preservation--guaranteed-eventual-agreement">Guaranteed eventual success + ordering preservation = guaranteed eventual agreement</h3>
<p>There&apos;s still one potential problem, though.</p>
<p>Imagine you send a message to your backend like &quot;set Twitter bio to &apos;I ate cockroaches&apos;&quot;. This times out: it&apos;s stuck in the network somewhere, being delayed, so it hasn&apos;t made it to the backend. You retry the operation after a while, and now it succeeds.</p>
<p>Now you realize the bio has a typo and send another message: &quot;set Twitter bio to &apos;I hate cockroaches&apos;&quot;. It succeeds.</p>
<p>But the first message is still out there, in the network. Say it eventually gets through to the backend. If the backend happily processes it, the bio will now read &quot;I ate cockroaches&quot;, while you still think it reads &quot;I hate cockroaches&quot;.</p>
<p>This is just one way, a subtle one, that <strong>messages can be processed in a different order than they&apos;re sent</strong>. Systems are rarely designed for it. Many naively assume a series of request-response communications necessarily result in client and server agreeing on the end result. Well, now you know better!</p>
<p>Another way out-of-order processing may happen is a <em>very</em> common frontend pitfall: sending <em>concurrent</em> (meaning: overlapping in time) AJAX requests that the user thinks are <em>serial</em> (meaning: not concurrent; one fully after another).</p>
<p>For example: the user writes &quot;I ate cockroaches&quot; and clicks &quot;Save&quot;, and you send an AJAX request to the backend. Now the user realizes the typo, writes &quot;I hate cockroaches&quot; and hits &quot;Save&quot; again. You immediately send an AJAX request again, even if the first one hasn&apos;t finished yet.</p>
<div class="mermaid">
sequenceDiagram
  participant F as Frontend
  participant N as Network (abstract)
  participant B as Backend

  F -&gt;&gt; N: set bio: &quot;I ate cockroaches&quot;

  note right of N: (Some time passes.)

  F -&gt;&gt; N: set bio: &quot;I hate cockroaches&quot;
  N -&gt;&gt;+ B: set bio: &quot;He hates cockroaches&quot;
  B --&gt;&gt;- N: OK
  N --&gt;&gt; F: OK

  note right of N: (First message finally gets delivered.)

  N -&gt;&gt;+ B: set bio: &quot;He ate cockroaches&quot;
  B --&gt;&gt;- N: Weird but OK
  N --&gt;&gt; F: OK
</div>

<p>Now, the previous request might not even have reached the backend yet. In fact, the next one may take a different path and reach the backend <em>first</em>. So the backend first processes &quot;set Twitter bio to &apos;I hate cockroaches&apos;&quot;, and, once the first request arrives, it processes &quot;set Twitter bio to &apos;I ate cockroaches&apos;&quot;. The user thinks they fixed the typo, but, from the backend&apos;s perspective, they <em>introduced</em> it later!</p>
<p>This situation can be fixed by <strong>telling the backend the order in which messages are supposed to be processed</strong>. There are several ways to do this; instead of &quot;do this&quot; and &quot;do that&quot;, messages might take the form &quot;1. do this&quot; and &quot;2. do that&quot;, or &quot;do this, as a first action&quot; and &quot;do that, after action &apos;do this&apos;&quot;. The backend can then <strong>detect messages received out of order</strong>, and act consequently.</p>
<p>With ordering preservation in place, we have the whole receipt for eventual agreement:</p>
<blockquote>
<p>If you do a series of idempotent operations, retry each of them until you see them succeed, and the backend preserves the order in which you sent them, then the backend and you agree on exactly which operations have been performed by you.</p>
</blockquote>
<p>This is a powerful guarantee that we&apos;ll explore in depth in the &quot;Distributed data&quot; section.</p>
<h4 id="tcp-has-your-back-except-not-really">TCP has your back, except not really</h4>
<p>In fact, communications do this <em>all the time</em> behind our backs. Most of the Internet runs on a protocol called <strong>TCP that has retries, idempotency, and ordering preservation</strong> built in.</p>
<p>But TCP can&apos;t fully save you:</p>
<ul>
<li><p>You <strong>rarely</strong> send all your communications between two computers through a <strong>single TCP connection</strong>. For example, in the &quot;set Twitter bio&quot; AJAX example before, each AJAX operation is a HTTP request, which browsers will typically send in different TCP connections.</p>
</li>
<li><p>Even if you do, TCP is a <em>transport layer</em> protocol: it just <strong>copies chunks of data from one computer to another</strong> and calls it a day. But <strong>operations are more than just meaningless data</strong>: they&apos;re <em>application level</em>, things that are processed and have consequences. You typically require confirmation by the backend that things were processed, because just receiving well-formed messages (what TCP guarantees) is only the beginning of the backend&apos;s job. So, just like TCP guarantees both ends eventually agree on which chunks of data were transferred, <em>you</em> need to guarantee your frontend and your backend agree on which operations were performed (if you want!).</p>
</li>
</ul>
<p>If you send message &quot;42. pay 1000 USD to Alice&quot; twice over the same TCP connection, TCP will happily ensure your backend receives something like:</p>
<pre><code>request arrived: &apos;&quot;42. pay 1000 USD to Alice&quot;&apos;;
request arrived: &apos;&quot;42. pay 1000 USD to Alice&quot;&apos;;
</code></pre><p>instead of an incomprehensible mess of arbitrarily duplicated, reordered, and missing chunks of data, like:</p>
<pre><code>ved: &apos;&quot;42. pay 10request arrirequest arri00 USD to Alicrequest are&quot;&apos;;
Alice&quot;&apos;;
Alice&quot;&apos;;
request arrived:
</code></pre><p>But it&apos;s up to your backend to ensure that you don&apos;t <em>do</em> operation 42 twice!</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="./" class="navigation navigation-prev " aria-label="Previous page: Programming a backend">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="02-serving-an-api.html" class="navigation navigation-next " aria-label="Next page: Serving an API">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"More than one computer","level":"1.2.1","depth":2,"next":{"title":"Serving an API","level":"1.2.2","depth":2,"path":"001-programming-a-backend/02-serving-an-api.md","ref":"001-programming-a-backend/02-serving-an-api.md","articles":[]},"previous":{"title":"Programming a backend","level":"1.2","depth":1,"path":"001-programming-a-backend/README.md","ref":"001-programming-a-backend/README.md","articles":[{"title":"More than one computer","level":"1.2.1","depth":2,"path":"001-programming-a-backend/01-more-than-one-computer.md","ref":"001-programming-a-backend/01-more-than-one-computer.md","articles":[]},{"title":"Serving an API","level":"1.2.2","depth":2,"path":"001-programming-a-backend/02-serving-an-api.md","ref":"001-programming-a-backend/02-serving-an-api.md","articles":[]},{"title":"The backend's backends","level":"1.2.3","depth":2,"path":"001-programming-a-backend/03-the-backends-backends.md","ref":"001-programming-a-backend/03-the-backends-backends.md","articles":[]}]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["anchorjs","mermaid-gb3","livereload"],"pluginsConfig":{"livereload":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"mermaid-gb3":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"001-programming-a-backend/01-more-than-one-computer.md","mtime":"2022-04-29T07:27:32.078Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2022-05-25T09:07:35.508Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-mermaid-gb3/book/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    <script src="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.min.js"></script>

    </body>
</html>

